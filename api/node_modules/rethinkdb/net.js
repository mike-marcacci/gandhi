// Generated by CoffeeScript 1.7.0
var Connection, HttpConnection, TcpConnection, ar, aropt, cursors, deconstructDatum, err, events, mkAtom, mkErr, net, pb, r, util, varar,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

net = require('net');

events = require('events');

util = require('./util');

err = require('./errors');

cursors = require('./cursor');

pb = require('./protobuf');

r = require('./ast');

ar = util.ar;

varar = util.varar;

aropt = util.aropt;

deconstructDatum = util.deconstructDatum;

mkAtom = util.mkAtom;

mkErr = util.mkErr;

Connection = (function(_super) {
  __extends(Connection, _super);

  Connection.prototype.DEFAULT_HOST = 'localhost';

  Connection.prototype.DEFAULT_PORT = 28015;

  Connection.prototype.DEFAULT_AUTH_KEY = '';

  Connection.prototype.DEFAULT_TIMEOUT = 20;

  function Connection(host, callback) {
    var conCallback, errCallback;
    if (typeof host === 'undefined') {
      host = {};
    } else if (typeof host === 'string') {
      host = {
        host: host
      };
    }
    this.host = host.host || this.DEFAULT_HOST;
    this.port = host.port || this.DEFAULT_PORT;
    this.db = host.db;
    this.authKey = host.authKey || this.DEFAULT_AUTH_KEY;
    this.timeout = host.timeout || this.DEFAULT_TIMEOUT;
    this.outstandingCallbacks = {};
    this.nextToken = 1;
    this.open = false;
    this.buffer = new Buffer(0);
    this._events = this._events || {};
    errCallback = (function(_this) {
      return function(e) {
        _this.removeListener('connect', conCallback);
        if (e instanceof err.RqlDriverError) {
          return callback(e);
        } else {
          return callback(new err.RqlDriverError("Could not connect to " + _this.host + ":" + _this.port + ".\n" + e.message));
        }
      };
    })(this);
    this.once('error', errCallback);
    conCallback = (function(_this) {
      return function() {
        _this.removeListener('error', errCallback);
        _this.open = true;
        return callback(null, _this);
      };
    })(this);
    this.once('connect', conCallback);
  }

  Connection.prototype._data = function(buf) {
    var response, responseBuffer, responseLength, _results;
    this.buffer = Buffer.concat([this.buffer, buf]);
    _results = [];
    while (this.buffer.length >= 4) {
      responseLength = this.buffer.readUInt32LE(0);
      if (!(this.buffer.length >= (4 + responseLength))) {
        break;
      }
      responseBuffer = this.buffer.slice(4, responseLength + 4);
      response = pb.ParseResponse(responseBuffer);
      this._processResponse(response);
      _results.push(this.buffer = this.buffer.slice(4 + responseLength));
    }
    return _results;
  };

  Connection.prototype._delQuery = function(token) {
    delete this.outstandingCallbacks[token];
    if (Object.keys(this.outstandingCallbacks).length < 1 && !this.open) {
      return this.cancel();
    }
  };

  Connection.prototype._processResponse = function(response) {
    var cb, cursor, opts, profile, root, token, _ref;
    token = response.token;
    profile = response.profile;
    if (profile != null) {
      profile = deconstructDatum(profile, {});
    }
    if (this.outstandingCallbacks[token] != null) {
      _ref = this.outstandingCallbacks[token], cb = _ref.cb, root = _ref.root, cursor = _ref.cursor, opts = _ref.opts;
      if (cursor != null) {
        cursor._addResponse(response);
        if (cursor._endFlag && cursor._outstandingRequests === 0) {
          return this._delQuery(token);
        }
      } else if (cb != null) {
        return pb.ResponseTypeSwitch(response, {
          "COMPILE_ERROR": (function(_this) {
            return function() {
              cb(mkErr(err.RqlCompileError, response, root));
              return _this._delQuery(token);
            };
          })(this),
          "CLIENT_ERROR": (function(_this) {
            return function() {
              cb(mkErr(err.RqlClientError, response, root));
              return _this._delQuery(token);
            };
          })(this),
          "RUNTIME_ERROR": (function(_this) {
            return function() {
              cb(mkErr(err.RqlRuntimeError, response, root));
              return _this._delQuery(token);
            };
          })(this),
          "SUCCESS_ATOM": (function(_this) {
            return function() {
              response = mkAtom(response, opts);
              if (Array.isArray(response)) {
                response = cursors.makeIterable(response);
              }
              if (profile != null) {
                response = {
                  profile: profile,
                  value: response
                };
              }
              cb(null, response);
              return _this._delQuery(token);
            };
          })(this),
          "SUCCESS_PARTIAL": (function(_this) {
            return function() {
              cursor = new cursors.Cursor(_this, token, opts, root);
              _this.outstandingCallbacks[token].cursor = cursor;
              if (profile != null) {
                return cb(null, {
                  profile: profile,
                  value: cursor._addResponse(response)
                });
              } else {
                return cb(null, cursor._addResponse(response));
              }
            };
          })(this),
          "SUCCESS_SEQUENCE": (function(_this) {
            return function() {
              cursor = new cursors.Cursor(_this, token, opts, root);
              _this._delQuery(token);
              if (profile != null) {
                return cb(null, {
                  profile: profile,
                  value: cursor._addResponse(response)
                });
              } else {
                return cb(null, cursor._addResponse(response));
              }
            };
          })(this),
          "WAIT_COMPLETE": (function(_this) {
            return function() {
              _this._delQuery(token);
              return cb(null, null);
            };
          })(this)
        }, (function(_this) {
          return function() {
            return cb(new err.RqlDriverError("Unknown response type"));
          };
        })(this));
      }
    } else {
      return this.emit('error', new err.RqlDriverError("Unexpected token " + token + "."));
    }
  };

  Connection.prototype.close = varar(0, 2, function(optsOrCallback, callback) {
    var cb, key, noreplyWait, opts, wrappedCb;
    if (callback != null) {
      opts = optsOrCallback;
      if (Object.prototype.toString.call(opts) !== '[object Object]') {
        throw new err.RqlDriverError("First argument to two-argument `close` must be an object.");
      }
      cb = callback;
    } else if (Object.prototype.toString.call(optsOrCallback) === '[object Object]') {
      opts = optsOrCallback;
      cb = null;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    for (key in opts) {
      if (!__hasProp.call(opts, key)) continue;
      if (key !== 'noreplyWait') {
        throw new err.RqlDriverError("First argument to two-argument `close` must be { noreplyWait: <bool> }.");
      }
    }
    if (!((cb == null) || typeof cb === 'function')) {
      throw new err.RqlDriverError("Final argument to `close` must be a callback function or object.");
    }
    wrappedCb = (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.open = false;
        if (cb != null) {
          return cb.apply(null, args);
        }
      };
    })(this);
    noreplyWait = ((opts.noreplyWait == null) || opts.noreplyWait) && this.open;
    if (noreplyWait) {
      return this.noreplyWait(wrappedCb);
    } else {
      return wrappedCb();
    }
  });

  Connection.prototype.noreplyWait = ar(function(callback) {
    var query, token;
    if (typeof callback !== 'function') {
      throw new err.RqlDriverError("First argument to noreplyWait must be a callback function.");
    }
    if (!this.open) {
      callback(new err.RqlDriverError("Connection is closed."));
      return;
    }
    token = this.nextToken++;
    query = {};
    query.type = "NOREPLY_WAIT";
    query.token = token;
    this.outstandingCallbacks[token] = {
      cb: callback,
      root: null,
      opts: null
    };
    return this._sendQuery(query);
  });

  Connection.prototype.cancel = ar(function() {
    return this.outstandingCallbacks = {};
  });

  Connection.prototype.reconnect = varar(1, 2, function(optsOrCallback, callback) {
    var cb, closeCb, opts;
    if (callback != null) {
      opts = optsOrCallback;
      cb = callback;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    if (typeof cb !== 'function') {
      throw new err.RqlDriverError("Final argument to `reconnect` must be a callback function.");
    }
    closeCb = (function(_this) {
      return function(err) {
        var constructCb;
        if (err != null) {
          return cb(err);
        } else {
          constructCb = function() {
            return _this.constructor.call(_this, {
              host: _this.host,
              port: _this.port
            }, cb);
          };
          return setTimeout(constructCb, 0);
        }
      };
    })(this);
    return this.close(opts, closeCb);
  });

  Connection.prototype.use = ar(function(db) {
    return this.db = db;
  });

  Connection.prototype._start = function(term, cb, opts) {
    var pair, query, token;
    if (!this.open) {
      throw new err.RqlDriverError("Connection is closed.");
    }
    token = this.nextToken++;
    query = {
      'global_optargs': []
    };
    query.type = "START";
    query.query = term.build();
    query.token = token;
    if (this.db != null) {
      pair = {
        key: 'db',
        val: r.db(this.db).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.useOutdated != null) {
      pair = {
        key: 'use_outdated',
        val: r.expr(!!opts.useOutdated).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.noreply != null) {
      pair = {
        key: 'noreply',
        val: r.expr(!!opts.noreply).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.profile != null) {
      pair = {
        key: 'profile',
        val: r.expr(!!opts.profile).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.durability != null) {
      pair = {
        key: 'durability',
        val: r.expr(opts.durability).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.batchConf != null) {
      pair = {
        key: 'batch_conf',
        val: r.expr(opts.batchConf).build()
      };
      query.global_optargs.push(pair);
    }
    if ((opts.noreply == null) || !opts.noreply) {
      this.outstandingCallbacks[token] = {
        cb: cb,
        root: term,
        opts: opts
      };
    }
    this._sendQuery(query);
    if ((opts.noreply != null) && opts.noreply && typeof cb === 'function') {
      return cb(null);
    }
  };

  Connection.prototype._continueQuery = function(token) {
    var query;
    query = {
      type: "CONTINUE",
      token: token
    };
    return this._sendQuery(query);
  };

  Connection.prototype._endQuery = function(token) {
    var query;
    query = {
      type: "STOP",
      token: token
    };
    return this._sendQuery(query);
  };

  Connection.prototype._sendQuery = function(query) {
    var data, lengthBuffer, totalBuf;
    query.accepts_r_json = true;
    data = pb.SerializeQuery(query);
    lengthBuffer = new Buffer(4);
    lengthBuffer.writeUInt32LE(data.length, 0);
    totalBuf = Buffer.concat([lengthBuffer, data]);
    return this.write(totalBuf);
  };

  return Connection;

})(events.EventEmitter);

TcpConnection = (function(_super) {
  __extends(TcpConnection, _super);

  TcpConnection.isAvailable = function() {
    return !process.browser;
  };

  function TcpConnection(host, callback) {
    var timeout;
    if (!TcpConnection.isAvailable()) {
      throw new err.RqlDriverError("TCP sockets are not available in this environment");
    }
    TcpConnection.__super__.constructor.call(this, host, callback);
    if (this.rawSocket != null) {
      this.close({
        noreplyWait: false
      });
    }
    this.rawSocket = net.connect(this.port, this.host);
    this.rawSocket.setNoDelay();
    timeout = setTimeout(((function(_this) {
      return function() {
        _this.rawSocket.destroy();
        return _this.emit('error', new err.RqlDriverError("Handshake timedout"));
      };
    })(this)), this.timeout * 1000);
    this.rawSocket.once('error', (function(_this) {
      return function() {
        return clearTimeout(timeout);
      };
    })(this));
    this.rawSocket.once('connect', (function(_this) {
      return function() {
        var buf, handshake_callback;
        buf = new Buffer(8);
        buf.writeUInt32LE(0x723081e1, 0);
        buf.writeUInt32LE(_this.authKey.length, 4);
        _this.write(buf);
        _this.rawSocket.write(_this.authKey, 'ascii');
        handshake_callback = function(buf) {
          var b, i, status_buf, status_str, _i, _len, _ref;
          _this.buffer = Buffer.concat([_this.buffer, buf]);
          _ref = _this.buffer;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            b = _ref[i];
            if (b === 0) {
              _this.rawSocket.removeListener('data', handshake_callback);
              status_buf = _this.buffer.slice(0, i);
              _this.buffer = _this.buffer.slice(i + 1);
              status_str = status_buf.toString();
              clearTimeout(timeout);
              if (status_str === "SUCCESS") {
                _this.rawSocket.on('data', function(buf) {
                  return _this._data(buf);
                });
                _this.emit('connect');
                return;
              } else {
                _this.emit('error', new err.RqlDriverError("Server dropped connection with message: \"" + status_str.trim() + "\""));
                return;
              }
            }
          }
        };
        return _this.rawSocket.on('data', handshake_callback);
      };
    })(this));
    this.rawSocket.on('error', (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.emit.apply(_this, ['error'].concat(__slice.call(args)));
      };
    })(this));
    this.rawSocket.on('close', (function(_this) {
      return function() {
        _this.open = false;
        return _this.emit('close', {
          noreplyWait: false
        });
      };
    })(this));
    this.rawSocket.on('timeout', (function(_this) {
      return function() {
        _this.open = false;
        return _this.emit('timeout');
      };
    })(this));
  }

  TcpConnection.prototype.close = varar(0, 2, function(optsOrCallback, callback) {
    var cb, opts, wrappedCb;
    if (callback != null) {
      opts = optsOrCallback;
      cb = callback;
    } else if (Object.prototype.toString.call(optsOrCallback) === '[object Object]') {
      opts = optsOrCallback;
      cb = null;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    if (!((cb == null) || typeof cb === 'function')) {
      throw new err.RqlDriverError("Final argument to `close` must be a callback function or object.");
    }
    wrappedCb = (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.rawSocket.end();
        if (cb != null) {
          return cb.apply(null, args);
        }
      };
    })(this);
    return TcpConnection.__super__.close.call(this, opts, wrappedCb);
  });

  TcpConnection.prototype.cancel = function() {
    this.rawSocket.destroy();
    return TcpConnection.__super__.cancel.call(this);
  };

  TcpConnection.prototype.write = function(chunk) {
    return this.rawSocket.write(chunk);
  };

  return TcpConnection;

})(Connection);

HttpConnection = (function(_super) {
  __extends(HttpConnection, _super);

  HttpConnection.prototype.DEFAULT_PROTOCOL = 'http';

  HttpConnection.isAvailable = function() {
    return typeof XMLHttpRequest !== "undefined";
  };

  function HttpConnection(host, callback) {
    var protocol, url, xhr;
    if (!HttpConnection.isAvailable()) {
      throw new err.RqlDriverError("XMLHttpRequest is not available in this environment");
    }
    HttpConnection.__super__.constructor.call(this, host, callback);
    protocol = host.protocol === 'https' ? 'https' : this.DEFAULT_PROTOCOL;
    url = "" + protocol + "://" + this.host + ":" + this.port + host.pathname + "ajax/reql/";
    xhr = new XMLHttpRequest;
    xhr.open("GET", url + "open-new-connection", true);
    xhr.responseType = "arraybuffer";
    xhr.onreadystatechange = (function(_this) {
      return function(e) {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            _this._url = url;
            _this._connId = (new DataView(xhr.response)).getInt32(0, true);
            return _this.emit('connect');
          } else {
            return _this.emit('error', new err.RqlDriverError("XHR error, http status " + xhr.status + "."));
          }
        }
      };
    })(this);
    xhr.send();
    this.xhr = xhr;
  }

  HttpConnection.prototype.cancel = function() {
    var xhr;
    this.xhr.abort();
    xhr = new XMLHttpRequest;
    xhr.open("POST", "" + this._url + "close-connection?conn_id=" + this._connId, true);
    xhr.send();
    this._url = null;
    this._connId = null;
    return HttpConnection.__super__.cancel.call(this);
  };

  HttpConnection.prototype.close = varar(0, 2, function(optsOrCallback, callback) {
    var cb, opts, wrappedCb;
    if (callback != null) {
      opts = optsOrCallback;
      cb = callback;
    } else if (Object.prototype.toString.call(optsOrCallback) === '[object Object]') {
      opts = optsOrCallback;
      cb = null;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    if (!((cb == null) || typeof cb === 'function')) {
      throw new err.RqlDriverError("Final argument to `close` must be a callback function or object.");
    }
    wrappedCb = (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.cancel();
        if (cb != null) {
          return cb.apply(null, args);
        }
      };
    })(this);
    return HttpConnection.__super__.close.call(this, opts, wrappedCb);
  });

  HttpConnection.prototype.write = function(chunk) {
    var array, i, view, xhr;
    xhr = new XMLHttpRequest;
    xhr.open("POST", "" + this._url + "?conn_id=" + this._connId, true);
    xhr.responseType = "arraybuffer";
    xhr.onreadystatechange = (function(_this) {
      return function(e) {
        var b, buf;
        if (xhr.readyState === 4 && xhr.status === 200) {
          buf = new Buffer((function() {
            var _i, _len, _ref, _results;
            _ref = new Uint8Array(xhr.response);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              b = _ref[_i];
              _results.push(b);
            }
            return _results;
          })());
          return _this._data(buf);
        }
      };
    })(this);
    array = new ArrayBuffer(chunk.length);
    view = new Uint8Array(array);
    i = 0;
    while (i < chunk.length) {
      view[i] = chunk[i];
      i++;
    }
    xhr.send(array);
    return this.xhr = xhr;
  };

  return HttpConnection;

})(Connection);

module.exports.isConnection = function(connection) {
  return connection instanceof Connection;
};

module.exports.connect = ar(function(host, callback) {
  if (!(typeof host === 'string' || Object.prototype.toString.call(host) === '[object Object]')) {
    throw new err.RqlDriverError("First argument to `connect` must be a string giving the " + "host to `connect` to or an object giving `host` and `port`.");
  }
  if (typeof callback !== 'function') {
    throw new err.RqlDriverError("Second argument to `connect` must be a callback to invoke with " + "either an error or the successfully established connection.");
  }
  if (TcpConnection.isAvailable()) {
    new TcpConnection(host, callback);
  } else if (HttpConnection.isAvailable()) {
    new HttpConnection(host, callback);
  } else {
    throw new err.RqlDriverError("Neither TCP nor HTTP avaiable in this environment");
  }
});
